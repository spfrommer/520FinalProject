import sys
import os.path as op
path = op.dirname(op.dirname(op.dirname(op.abspath(__file__))))
print('Setting project root path: ' + path)
sys.path.append(path)

import random
from colorama import init, Fore
import os

from airsim import dirs
from airsim import sim
from airsim import presets
from airsim import io_utils
from airsim.airfoil import Airfoil, AirfoilElement

import pyeasyga
import gene_utils as genes
from gene_utils import Constraint

# Initialize terminal colors
init()

### INITIALIZE
constraints = {}
constraints["elem_constraints"] = [
        Constraint().wdx(0,0).wdy(0,0).wrot(-40,-12).wchord(0.076,0.076),
        Constraint().wdx(-0.03,0.04).wdy(0.01,0.07).wrot(0,20).wchord(0.457,0.457),
        Constraint().wdx(-0.05,0.02).wdy(0.01,0.05).wrot(20,60).wchord(0.191,0.191),
        Constraint().wdx(-0.05,0.02).wdy(0.01,0.05).wrot(30,75).wchord(0.114,0.114)]

def ga_init():
    ga = pyeasyga.GeneticAlgorithm([],
                                   population_size=10,
                                   generations=450,
                                   crossover_probability=0.5,
                                   mutation_probability=0.85,
                                   elitism=True,
                                   maximise_fitness=True)

    pop_path = dirs.out_path("pop")
    if os.path.isfile(pop_path):
        ga.current_generation = io_utils.read_data(pop_path)
        _, _, files = next(os.walk(dirs.out_path("airfoils")))
        file_count = len(files)
        ga.generation_count = file_count
        print(Fore.LIGHTMAGENTA_EX + "Resuming previous optimization " +
                "from generation " + str(file_count))
    else:
        print(Fore.LIGHTMAGENTA_EX + "Starting new optimization")

    return ga

ga = ga_init()

### SEEDING
def create_individual(_):
    return genes.constrained_random(constraints)

ga.create_individual = create_individual

### MUTATION
def get_constraint_range(gene_index):
    constraint = constraints["elem_constraints"][gene_index // 4]
    range_map = {
        0: constraint.dx,
        1: constraint.dy,
        2: constraint.rot,
        3: constraint.chord
    }
    constraint_range = range_map[gene_index % 4]
    return constraint_range[1] - constraint_range[0]

def mutate(individual):
    count = 3 # How many genes get mutated
    for _ in range(0, count):
        gene = random.randrange(len(individual))
        constraint_range = get_constraint_range(gene)

        individual[gene] += random.uniform(-constraint_range / 2,
                                            constraint_range / 2)
    
    return genes.constrain(individual, constraints)

ga.mutate_function = mutate

### CROSSOVER
def crossover(mother, father):
    # Single-point crossover
    i = random.randrange(len(mother))

    m1 = mother[:i]
    m2 = mother[i:]

    f1 = father[:i]
    f2 = father[i:]

    son = mother[:i] + father[i:]
    daughter = father[:i] + mother[i:]
	
    return (genes.constrain(son, constraints),
            genes.constrain(daughter, constraints))

ga.crossover_function = crossover

### SELECTION
ga.selection_function = ga.tournament_selection
ga.tournament_size = 2

### FITNESS

# Maps genes to an array of fitness values
# fitness values are generated by giving the gene small random changes
# before calculating the fitness value. The fitness of a gene is then
# the average of the random fitness values
fitness_path = dirs.out_path("stored_fitness")
if os.path.isfile(fitness_path):
    print(Fore.LIGHTMAGENTA_EX + "Reloading fitness values")
    stored_fitness = io_utils.read_data(fitness_path)
else:
    print(Fore.LIGHTMAGENTA_EX + "Initializing empty fitness values")
    stored_fitness = {}

def fitness(individual, _):
    airfoil = genes.to_airfoil(genes.jiggle(individual))
    airfoil.set_profile_coords(presets.s1223)
    
    try:
        sim_out = sim.analyze_airfoil(airfoil,
                      presets.fine_lead_mesh_scheme(airfoil))
        fitness = -sim_out["lift"]
       
        fitness_array = stored_fitness.get(tuple(individual), [])

        # Sanity check
        if fitness <= 100:
            fitness_array.append(fitness)

        stored_fitness[tuple(individual)] = fitness_array
        
        if fitness_array:
            return float(sum(fitness_array))/len(fitness_array)
        else:
            return 0

    except KeyboardInterrupt:
        print("Got keyboard interrupt!")
        raise
    except Exception as e:
        print("Got non-interrupt error")
        print(e)
        return 0

ga.fitness_function = fitness

### GENERATION OUTPUT
def write_summary(constraints, ga, path):
    with open(path, "w") as f:
        f.write("Fitness: df\n")
        f.write("Constraints:\n")
        for constraint in constraints["elem_constraints"]:
            f.write("dx: {} dy: {} rot: {} chord:{}\n".format(
                    constraint.dx, constraint.dy,
                    constraint.rot, constraint.chord))

        f.write("\nBest genome:\n")
        f.write("Fitness: " + str(ga.current_generation[0].fitness) + "\n")
        best = ga.current_generation[0].genes 
        f.write(str(best) + "\n")
        f.write(genes.to_string(ga.current_generation[0].genes) + "\n")

        f.write("Overall size:\n")
        f.write(str(genes.overall_size(best)))
        
        f.write("\nConfig:\n")
        f.write(str({"population": ga.population_size, "generations": ga.generations, "crossover": ga.crossover_probability, "mutation": ga.mutation_probability, "elitism": ga.elitism}))

def notify(population, gen):
    print(Fore.LIGHTMAGENTA_EX + "Finished generation: " + str(gen))
    print(population)
    best = population[0]
    fitness = best.fitness
    individual = best.genes

    airfoil = genes.to_airfoil(individual)
    airfoil.set_profile_coords(presets.s1223)

    io_utils.write_airfoil_xml(airfoil, dirs.out_path("airfoils",
                               "airfoil{}.xml".format(gen)))
    io_utils.write_dict_json({"fitness": fitness,
                    "samples": len(stored_fitness[tuple(best.genes)])},
                    dirs.out_path("stats", "stat{}.txt".format(gen)))
    io_utils.write_data(ga.current_generation, dirs.out_path("pop"))
    io_utils.write_data(stored_fitness, dirs.out_path("stored_fitness"))
    io_utils.run_command(["node", "airrender/render.js",
                          "--fitness", "--history"])
    write_summary(constraints, ga, dirs.out_path("summary.txt"))

ga.notify_function = notify
ga.notify_skip = 1

### RUNNING
ga.run()
print(Fore.GREEN + "Done!")
